import json
import logging

from fastapi import APIRouter, HTTPException, Request
from fastapi.responses import StreamingResponse

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/api")


@router.post("/dev-tools/generate-cookies-stream")
async def generate_cookies_stream(request: Request):
    from backend.core.ai_client import get_async_openai_client
    from backend.config.ai_config import get_openai_config

    try:
        data = await request.json()
        cookies_text = data.get("cookies_text", "").strip()

        if not cookies_text:
            raise HTTPException(status_code=400, detail="Cookies内容不能为空")

        config = get_openai_config()
        client = get_async_openai_client()

        if not client:
            raise HTTPException(status_code=503, detail="AI服务不可用")

        prompt = f"""请将以下 B 站 Cookies 转换为标准的 Netscape HTTP Cookie File 格式。

输入 Cookies:
{cookies_text}

严格要求：
1. 第一行：# Netscape HTTP Cookie File
2. 第二行：# This file is generated by yt-dlp.  Do not edit.
3. 第三行：空行
4. 从第四行开始，每个 cookie 占一行，字段顺序严格为：
   domain[TAB]flag[TAB]path[TAB]secure[TAB]expiration[TAB]name[TAB]value
5. 所有字段之间必须使用制表符（Tab）分隔，而不是空格。
6. 固定字段值：
   - domain = .bilibili.com
   - flag = TRUE
   - path = /
   - secure = FALSE
   - expiration = 1893456000
7. 从输入中提取所有 cookie 的 name 和 value。
8. 绝对不要输出任何Markdown代码块标记（如```），不要输出任何解释文字，只输出纯文本内容。
9. 直接从第一个字符开始输出"# Netscape HTTP Cookie File"。

期望输出格式示例：

# Netscape HTTP Cookie File
# This file is generated by yt-dlp.  Do not edit.

.bilibili.com\tTRUE\t/\tFALSE\t1893456000\t_uuid\tvalue1
.bilibili.com\tTRUE\t/\tFALSE\t1893456000\tSESSDATA\tvalue2
"""

        async def event_generator():
            try:
                stream = await client.chat.completions.create(
                    model=config.model,
                    messages=[
                        {"role": "system", "content": "你是Netscape Cookie格式转换专家。只输出标准格式的cookie文件内容，不添加任何解释。"},
                        {"role": "user", "content": prompt},
                    ],
                    temperature=0,
                    stream=True,
                )

                async for chunk in stream:
                    if chunk.choices[0].delta.content:
                        content = chunk.choices[0].delta.content
                        yield f"data: {json.dumps({'content': content}, ensure_ascii=False)}\n\n"

                yield f"data: {json.dumps({'done': True}, ensure_ascii=False)}\n\n"
                logger.info("Cookies转换流式输出完成")
            except Exception as e:
                logger.error(f"流式转换失败: {e}")
                yield f"data: {json.dumps({'error': str(e)}, ensure_ascii=False)}\n\n"

        return StreamingResponse(
            event_generator(),
            media_type="text/event-stream",
            headers={"Cache-Control": "no-cache", "Connection": "keep-alive", "Access-Control-Allow-Origin": "*"},
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Cookies转换失败: {str(e)}")
        raise HTTPException(status_code=500, detail=f"转换失败: {str(e)}")
